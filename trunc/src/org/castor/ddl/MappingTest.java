package org.castor.ddl;

import java.util.Enumeration;

import org.exolab.castor.jdo.engine.JDOClassDescriptor;
import org.exolab.castor.jdo.engine.JDOFieldDescriptor;
import org.exolab.castor.mapping.FieldDescriptor;
import org.exolab.castor.mapping.Mapping;
import org.exolab.castor.mapping.MappingResolver;
import org.exolab.castor.mapping.xml.ClassMapping;
import org.exolab.castor.mapping.xml.FieldMapping;
import org.exolab.castor.mapping.xml.MappingRoot;
//import org.exolab.castor.util.DTDResolver;
//import org.xml.sax.EntityResolver;

public class MappingTest {
    private static final String MAPPING = "xml/mapping.xml";
    
    public static void main(final String[] args) throws Exception {
        // Create a instance of Mapping class with current classloader. As an 
        // alternative you can also specify a specific classloader to use.
        //   Mapping mapping = new Mapping(loader);
        Mapping mapping = new Mapping();
        
        // Constructor of Mapping class initializes its internal EntityResolver
        // with an instance of DTDResolver. DTDResolver is used to load some Castor
        // specific files refered in mapping from castor.jar instead of loading
        // them always from internet. Examples of such files are mapping.dtd or
        // mapping.xml. If you need to change the devault behaviour to resolve
        // entities (files) you are able to set your own implementation of
        // EntityResolver with:
        //   EntityResolver resolver = new DTDResolver();
        //   mapping.setEntityResolver(resolver);
        
        // Normally Mapping class loads files only with absolute filenames. If you
        // need to load files relative to a base URL you can set it as follows:
        //   mapping.setBaseURL(baseURI);
        
        // If bas URL is not set you need to specify absolute file names when
        // loading a mapping.
        String abs = MAPPING;//MappingTest.class.getResource(MAPPING).toExternalForm();
        mapping.loadMapping(abs);
        
        // Now there are 2 ways how to access the mapping information. The first one
        // is to walk through the classes generated by source generator out of
        // mapping.xsd. These classes are all located under:
        //   src/main/java/org/exolab/castor/mapping/xml/
        // and can be access as follows:
        MappingRoot root = mapping.getRoot();
        Enumeration ec = root.enumerateClassMapping();
        while (ec.hasMoreElements()) {
            ClassMapping cm = (ClassMapping) ec.nextElement();
            System.out.println("class1:" + cm.getName());
            System.out.println("  table1:" + cm.getMapTo().getTable());
            
            StringBuffer sb = new StringBuffer("  identities1:");
            String[] ids = cm.getIdentity();
            for (int i = 0; i < ids.length; i++) {
                if (i != 0) { sb.append("/"); }
                sb.append(ids[i]);
            }
            System.out.println(sb.toString());
            
            sb = new StringBuffer();
            Enumeration ef = cm.getClassChoice().enumerateFieldMapping();
            while (ef.hasMoreElements()) {
                FieldMapping fm = (FieldMapping) ef.nextElement();
                sb.append("  field1:");
                sb.append(fm.getName());
                sb.append("  column1:");
                String[] sqlnames = fm.getSql().getName();
                for (int i = 0; i < sqlnames.length; i++) {
                    if (i != 0) { sb.append("/"); }
                    sb.append(sqlnames[i]);
                }
                sb.append("  type1:");
                sb.append(fm.getSql().getType());
                sb.append("\n");
            }
            System.out.println(sb.toString());
        }
        
        // The second and prefered alternative to access mapping information is through
        // ClassDescriptor and FieldDescriptor. When calling mapping.getResolver(..)
        // a specific MappingLoader is instantiated that converts the information of
        // the generated classes into the descriptors. The big advantage of the
        // descriptors is that they are independent of the mapping syntax while the
        // generated classes aren't. Working with the descriptors therefor will allow
        // us to change the mapping syntax or even add support for a totally different
        // mapping (e.g. anotations) without changing anything at DDLGenerator.
        MappingResolver mr = mapping.getResolver(Mapping.JDO);
        Enumeration ecd = mr.listDescriptors();
        while (ecd.hasMoreElements()) {
            JDOClassDescriptor cd = (JDOClassDescriptor) ecd.nextElement();
            System.out.println("class2:" + cd.getJavaClass().getName());
            System.out.println("  table2:" + cd.getTableName());
            
            StringBuffer sb = new StringBuffer("  identities2:");
            FieldDescriptor[] idfds = cd.getIdentities();
            for (int i = 0; i < idfds.length; i++) {
                if (i != 0) { sb.append("/"); }
                sb.append(idfds[i].getFieldName());
            }
            System.out.println(sb.toString());
            
            sb = new StringBuffer();
            FieldDescriptor[] fds = cd.getFields();
            for (int i = 0; i < fds.length; i++) {
                JDOFieldDescriptor fd = (JDOFieldDescriptor) fds[i];
                sb.append("  field2:");
                sb.append(fd.getFieldName());
                sb.append("  column2:");
                String[] sqlnames = fd.getSQLName();
                if (sqlnames != null) {
                    for (int j = 0; j < sqlnames.length; j++) {
                        if (j != 0) { sb.append("/"); }
                        sb.append(sqlnames[j]);
                    }
                }
                sb.append("  type2:");
                sb.append(fd.getFieldType());
                sb.append("\n");
            }
            System.out.println(sb.toString());
        }
    }
}
